import { Rectangle, TranslationResult } from './types';
import { TypedError } from './utils';

const OVERLAY_ID = 'select-and-translate-overlay';
const CANVAS_ID = 'select-and-translate-canvas';
const POPUP_CLASS = 'select-and-translate-popup';
const MAXIMUM_Z_INDEX = '2147483647';
const SELECTION_TIMEOUT = 120000;
const ORIGINAL_STYLES = {
  html: {
    overflow: '',
    scrollbarWidth: '',
  },
  body: {
    overflow: '',
    marginRight: '',
  },
};

function hideScrollbars() {
  // Save original styles
  ORIGINAL_STYLES.html.overflow = document.documentElement.style.overflow;
  ORIGINAL_STYLES.html.scrollbarWidth =
    document.documentElement.style.scrollbarWidth;
  ORIGINAL_STYLES.body.overflow = document.body.style.overflow;
  ORIGINAL_STYLES.body.marginRight = document.body.style.marginRight;

  const scrollbarWidth =
    window.innerWidth - document.documentElement.clientWidth;

  // Hide scrollbars on HTML
  document.documentElement.style.overflow = 'hidden';
  document.documentElement.style.scrollbarWidth = 'none'; // For Firefox

  // Hide scrollbars on BODY and compensate for scrollbar width
  document.body.style.overflow = 'hidden';
  document.body.style.marginRight = `${scrollbarWidth}px`;
}

function restoreScrollbars() {
  document.documentElement.style.overflow = ORIGINAL_STYLES.html.overflow || '';
  document.documentElement.style.scrollbarWidth =
    ORIGINAL_STYLES.html.scrollbarWidth || '';
  document.body.style.overflow = ORIGINAL_STYLES.body.overflow || '';
  document.body.style.marginRight = ORIGINAL_STYLES.body.marginRight || '';
}

function existingCanvasAndOverlayCleanup() {
  detachCanvasFromViewport();
  detachOverlayFromViewport();
}

async function createCanvas(
  id: string = CANVAS_ID
): Promise<[HTMLCanvasElement, CanvasRenderingContext2D]> {
  return new Promise<[HTMLCanvasElement, CanvasRenderingContext2D]>(
    (resolve, reject) => {
      const canvas = document.createElement('canvas');
      canvas.id = id;

      const ctx = canvas.getContext('2d');
      if (!ctx) {
        reject(
          new TypedError(
            'DOMCanvasError',
            "Canvas 2D context is not available. This may occur if your browser doesn't support canvas or has disabled it."
          )
        );
        return;
      }

      resolve([canvas, ctx]);
      return;
    }
  );
}

export async function loadImageOntoCanvas(
  imageDataUrl: string
): Promise<[HTMLCanvasElement, CanvasRenderingContext2D]> {
  existingCanvasAndOverlayCleanup();

  try {
    const [canvas, ctx] = await createCanvas();
    const img = new Image();

    return new Promise<[HTMLCanvasElement, CanvasRenderingContext2D]>(
      (resolve, reject) => {
        img.onload = () => {
          try {
            canvas.width = img.width;
            canvas.height = img.height;

            ctx.drawImage(img, 0, 0, img.width, img.height);

            Object.assign(canvas.style, {
              position: 'fixed',
              top: '0',
              left: '0',
              right: '0',
              bottom: '0',
              width: '100%',
              height: '100%',
              zIndex: MAXIMUM_Z_INDEX,
              pointerEvents: 'auto',
            });

            document.body.appendChild(canvas);
            resolve([canvas, ctx]);
          } catch (error) {
            reject(error);
          }
        };

        img.onerror = () => {
          existingCanvasAndOverlayCleanup();
          reject(
            new TypedError(
              'DOMCanvasError',
              'Failed to load image, try to refresh the page. This might be due to content security policy restrictions or an invalid image format.'
            )
          );
        };

        img.src = imageDataUrl;
      }
    );
  } catch (error) {
    existingCanvasAndOverlayCleanup();
    throw error;
  }
}

export async function selectAndCropImage(
  imageDataUrl: string
): Promise<HTMLCanvasElement> {
  try {
    const [canvas, ctx] = await loadImageOntoCanvas(imageDataUrl);

    appendOverlayToViewport();

    const rectangle = await applyEventListenerToOverlay();
    const scaleX = ctx.canvas.width / window.innerWidth;
    const scaleY = ctx.canvas.height / window.innerHeight;

    const scaledRectangle = {
      x: rectangle.x * scaleX,
      y: rectangle.y * scaleY,
      width: rectangle.width * scaleX,
      height: rectangle.height * scaleY,
    };

    return await cropCanvas(canvas, scaledRectangle);
  } catch (error) {
    existingCanvasAndOverlayCleanup();
    throw error;
  }
}

function detachCanvasFromViewport() {
  try {
    const canvas = document.getElementById(CANVAS_ID);
    if (canvas && document.body.contains(canvas)) {
      document.body.removeChild(canvas);
    }

    const anyCanvases = document.querySelectorAll(`canvas[id^="${CANVAS_ID}"]`);
    anyCanvases.forEach((element) => element.remove());
  } catch (error) {
    throw new TypedError(
      'DOMCanvasError',
      `Failed to remove canvas, try to refresh the page: ${
        error instanceof Error ? error.message : String(error)
      }`
    );
  }
}

function detachOverlayFromViewport() {
  try {
    const overlay = document.getElementById(OVERLAY_ID);
    if (overlay && document.body.contains(overlay)) {
      document.body.removeChild(overlay);
    }

    const anyOverlays = document.querySelectorAll(`div[id^="${OVERLAY_ID}"]`);
    anyOverlays.forEach((element) => element.remove());

    restoreScrollbars();
  } catch (error) {
    restoreScrollbars();

    throw new TypedError(
      'DOMOverlayError',
      `Failed to remove overlay, try to refresh the page: ${
        error instanceof Error ? error.message : String(error)
      }`
    );
  }
}

function appendOverlayToViewport() {
  try {
    detachOverlayFromViewport();
    hideScrollbars();

    const overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;

    Object.assign(overlay.style, {
      position: 'fixed',
      top: '0',
      left: '0',
      right: '0',
      bottom: '0',
      width: '100%',
      height: '100%',
      backgroundColor: 'rgba(0,0,0,0.5)',
      zIndex: MAXIMUM_Z_INDEX,
      pointerEvents: 'auto',
    });

    document.body.appendChild(overlay);
  } catch (error) {
    throw new TypedError(
      'DOMOverlayError',
      `Failed to append the overlay to viewport: ${
        error instanceof Error ? error.message : String(error)
      }`
    );
  }
}

function applyEventListenerToOverlay(): Promise<Rectangle> {
  return new Promise((resolve, reject) => {
    const overlay = document.getElementById(OVERLAY_ID);
    if (overlay === null) {
      reject(
        new TypedError(
          'DOMElementMissingError',
          'Overlay element not found in the document'
        )
      );
      return;
    }

    let isCleanedUp = false;

    const timeoutId = setTimeout(() => {
      if (!isCleanedUp) {
        cleanup();
        reject(
          new TypedError(
            'TimeoutReached',
            `Selection timed out after ${
              SELECTION_TIMEOUT / 60000
            } minutes of inactivity`,
            false
          )
        );
      }
    }, SELECTION_TIMEOUT);

    const cleanup = () => {
      if (isCleanedUp) return;

      clearTimeout(timeoutId);
      window.removeEventListener('keydown', onEscape);
      overlay.removeEventListener('pointerdown', onMouseDown);
      detachOverlayFromViewport();
      detachCanvasFromViewport();

      isCleanedUp = true;
    };

    const onEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        cleanup();
        reject(
          new TypedError('UserEscapeKeyPressed', 'Action canceled', false)
        );
        return;
      }
    };

    window.addEventListener('keydown', onEscape);

    const onMouseDown = (e: PointerEvent) => {
      try {
        e.preventDefault();
        overlay.setPointerCapture(e.pointerId);

        const xDown = e.clientX;
        const yDown = e.clientY;
        const selectionBox = createSelectionBox();

        overlay.style.backgroundColor = 'transparent';
        overlay.appendChild(selectionBox);

        const handleWindowBlur = () => {
          if (!isCleanedUp && selectionBox) {
            const fakePointerEvent = new PointerEvent('pointerup');
            onMouseUp(fakePointerEvent);
          }
        };

        window.addEventListener('blur', handleWindowBlur);

        const onMouseMove = (e: PointerEvent) => {
          try {
            e.preventDefault();

            const xMove = e.clientX;
            const yMove = e.clientY;

            const width = Math.abs(xMove - xDown);
            const height = Math.abs(yMove - yDown);
            const left = Math.min(xMove, xDown);
            const top = Math.min(yMove, yDown);

            selectionBox.style.left = `${left}px`;
            selectionBox.style.top = `${top}px`;
            selectionBox.style.width = `${width}px`;
            selectionBox.style.height = `${height}px`;
          } catch (error) {
            cleanup();
            reject(
              new TypedError(
                'DOMEventListenerError',
                `Error during mouse move: ${
                  error instanceof Error ? error.message : String(error)
                }`
              )
            );
            return;
          }
        };

        const onMouseUp = (_: PointerEvent) => {
          try {
            overlay.releasePointerCapture(e.pointerId);

            const rect = selectionBox.getBoundingClientRect();
            if (rect.width === 0 || rect.height === 0) {
              cleanup();
              reject(new Error('Selection area cannot be empty'));
              return;
            }

            overlay.removeEventListener('pointerup', onMouseUp);
            overlay.removeEventListener('pointermove', onMouseMove);
            window.removeEventListener('blur', handleWindowBlur);

            const rectangle = {
              x: rect.left,
              y: rect.top,
              width: rect.width,
              height: rect.height,
            };

            cleanup();

            resolve(rectangle);
          } catch (error) {
            cleanup();
            reject(
              new TypedError(
                'DOMEventListenerError',
                `Error finalizing selection: ${
                  error instanceof Error ? error.message : String(error)
                }`
              )
            );
            return;
          }
        };

        overlay.addEventListener('pointermove', onMouseMove, {
          passive: false,
        });
        overlay.addEventListener('pointerup', onMouseUp, { passive: false });
      } catch (error) {
        cleanup();
        reject(
          new TypedError(
            'DOMEventListenerError',
            `Error initializing selection: ${
              error instanceof Error ? error.message : String(error)
            }`
          )
        );
        return;
      }
    };

    overlay.addEventListener('pointerdown', onMouseDown, { passive: false });
  });
}

function createSelectionBox(): HTMLDivElement {
  const box = document.createElement('div');
  Object.assign(box.style, {
    position: 'fixed',
    zIndex: '2147483647',
    boxShadow: '0 0 0 100vw rgba(0,0,0,0.5)',
    outline: '2px dashed white',
  });
  return box;
}

function cropCanvas(
  canvas: HTMLCanvasElement,
  rectangle: Rectangle
): Promise<HTMLCanvasElement> {
  return new Promise((resolve, reject) => {
    try {
      // Validate crop rectangle bounds
      const isOutOfBounds =
        rectangle.x < 0 ||
        rectangle.y < 0 ||
        rectangle.x + rectangle.width > canvas.width ||
        rectangle.y + rectangle.height > canvas.height;

      if (isOutOfBounds) {
        reject(
          new TypedError('SelectionBoxError', 'Image do not have proper size')
        );
        return;
      }

      const croppedCanvas = document.createElement('canvas');
      croppedCanvas.width = rectangle.width;
      croppedCanvas.height = rectangle.height;

      const ctx = croppedCanvas.getContext('2d');
      if (!ctx)
        return reject(
          new TypedError('DOMCanvasError', 'Canvas context not available')
        );

      ctx.drawImage(
        canvas,
        rectangle.x,
        rectangle.y,
        rectangle.width,
        rectangle.height,
        0,
        0,
        rectangle.width,
        rectangle.height
      );

      resolve(croppedCanvas);
    } catch (error) {
      reject(
        new TypedError(
          'DOMCanvasError',
          `Failed to crop canvas: ${
            error instanceof Error ? error.message : String(error)
          }`
        )
      );
    }
  });
}

function getThemeColors() {
  const themes = {
    dark: {
      backgroundColor: 'rgba(22, 22, 22, 1)',
      color: 'white',
      border: '1px solid rgba(255, 255, 255, 0.3)',
    },
    light: {
      backgroundColor: 'rgba(245, 245, 245, 1)',
      color: '#333',
      border: '1px solid rgba(0, 0, 0, 0.2)',
    },
  };

  // Determine preferred theme based on system preference
  const prefersDarkTheme = window.matchMedia(
    '(prefers-color-scheme: dark)'
  ).matches;

  return prefersDarkTheme ? themes.dark : themes.light;
}

function createPopup(text: TranslationResult): HTMLDivElement {
  try {
    // Create the main container that will host the shadow DOM
    const container = document.createElement('div');
    container.classList.add(POPUP_CLASS);

    // Create a shadow root to isolate our styles from the page
    const shadowRoot = container.attachShadow({ mode: 'closed' });

    // Create the main popup div inside the shadow DOM
    const div = document.createElement('div');

    const theme = getThemeColors();

    // Add a style element inside the shadow DOM to define all styles
    const style = document.createElement('style');
    style.textContent = `
      .popup-container {
        width: 40rem;
        max-width: 50vw;
        height: auto;
        max-height: 50vh;
        box-sizing: border-box;
        overflow: hidden;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: ${theme.backgroundColor};
        color: ${theme.color};
        border: ${theme.border};
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        transition: all 0.3s ease;
        padding: 1rem;
        cursor: default;
        display: flex;
        flex-direction: column;
        opacity: 1;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      }
      
      .popup-header {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 2.5rem;
        cursor: move;
        border-bottom: ${theme.border};
        border-top-left-radius: 8px;
        border-top-right-radius: 8px;
        background-color: rgba(0, 0, 0, 0.05);
        padding: 0.5rem 1rem;
        display: flex;
        align-items: center;
      }
      
      .header-title {
        font-weight: bold;
        user-select: none;
      }
      
      .close-button {
        position: absolute;
        top: 10px;
        right: 10px;
        border: none;
        background: transparent;
        font-size: 1.5rem;
        color: ${theme.color};
        cursor: pointer;
      }
      
      .content-container {
        margin-top: 2.5rem;
        display: flex;
        flex-direction: column;
        width: 100%;
        height: calc(100% - 5rem);
        position: relative;
        user-select: text;
        overflow: hidden;
      }
      
      .text-div {
        margin: 0.5rem;
        padding: 1rem;
        flex: 1;
        overflow-y: auto;
        word-break: break-word;
      }
      
      .text-title {
        margin-bottom: 0.5rem;
      }
      
      .divider {
        width: 1px;
        align-self: stretch;
        margin: 0 1rem;
        background-color: ${theme.border.split(' ')[2]};
        flex-shrink: 0;
      }
      
      .footer {
        display: flex;
        justify-content: space-between;
        padding: 0.5rem;
        margin-top: 0.5rem;
        border-top: ${theme.border};
      }
      
      .btn {
        padding: 0.25rem 0.5rem;
        border: ${theme.border};
        border-radius: 4px;
        background-color: transparent;
        color: ${theme.color};
        cursor: pointer;
      }
      
      .btn:hover {
        background-color: rgba(0, 0, 0, 0.05);
      }
    `;

    shadowRoot.appendChild(style);

    div.className = 'popup-container';

    // Create a draggable header area
    const header = document.createElement('div');
    header.className = 'popup-header';

    const headerTitle = document.createElement('span');
    headerTitle.textContent = 'Translation';
    headerTitle.className = 'header-title';
    header.appendChild(headerTitle);

    // Add close button early so we can reference it in event handlers
    const closeButton = document.createElement('button');
    closeButton.innerText = '×';
    closeButton.className = 'close-button';

    // Make the header draggable
    let isDragging = false;
    let offsetX = 0;
    let offsetY = 0;

    // Attach the mousedown event to the header
    header.addEventListener('mousedown', (e) => {
      // Ensure we're not clicking a button
      if (
        e.target === closeButton ||
        (e.target as Element).tagName === 'BUTTON'
      ) {
        return;
      }

      isDragging = true;

      // Get position relative to viewport, not the container
      const rect = container.getBoundingClientRect();
      offsetX = e.clientX - rect.left;
      offsetY = e.clientY - rect.top;

      // Disable transition for smoother dragging
      container.style.transition = 'none';

      // Prevent text selection during drag
      e.preventDefault();
    });

    // These handlers need to be on document to catch all mouse movements
    const mouseMoveHandler = (e: MouseEvent) => {
      if (!isDragging) return;

      // Set absolute position based on mouse position and initial offset
      container.style.left = `${e.clientX - offsetX}px`;
      container.style.top = `${e.clientY - offsetY}px`;

      // Important: Remove the transform that centers the popup
      container.style.transform = 'none';
    };

    const mouseUpHandler = () => {
      if (isDragging) {
        isDragging = false;
        container.style.transition = 'all 0.3s ease';
      }
    };

    // Add the document level handlers
    document.addEventListener('mousemove', mouseMoveHandler);
    document.addEventListener('mouseup', mouseUpHandler);

    const contentContainer = document.createElement('div');
    contentContainer.className = 'content-container';

    const originalDiv = document.createElement('div');
    originalDiv.className = 'text-div';

    const originalTitle = document.createElement('h3');
    originalTitle.innerText = 'Original Text';
    originalTitle.className = 'text-title';

    const p1 = document.createElement('p');
    p1.innerText = text.originalText;
    p1.classList.add('original-text-content');

    originalDiv.appendChild(originalTitle);
    originalDiv.appendChild(p1);

    // Center divider
    const divider = document.createElement('div');
    divider.className = 'divider';

    const translatedDiv = document.createElement('div');
    translatedDiv.className = 'text-div';

    const translatedTitle = document.createElement('h3');
    translatedTitle.innerText = 'Translated Text';
    translatedTitle.className = 'text-title';

    const p2 = document.createElement('p');
    p2.innerText = text.translatedText;
    p2.classList.add('translated-text-content');

    translatedDiv.appendChild(translatedTitle);
    translatedDiv.appendChild(p2);

    const footer = document.createElement('div');
    footer.className = 'footer';

    const createButton = (text: string, onClick: () => void) => {
      const button = document.createElement('button');
      button.innerText = text;
      button.className = 'btn';
      button.addEventListener('click', onClick);
      return button;
    };

    const copyOriginalBtn = createButton('Copy Original', () => {
      navigator.clipboard.writeText(text.originalText);
    });

    const copyTranslatedBtn = createButton('Copy Translation', () => {
      navigator.clipboard.writeText(text.translatedText);
    });

    footer.appendChild(copyOriginalBtn);
    footer.appendChild(copyTranslatedBtn);

    closeButton.onclick = () => {
      // Remove document event listeners to prevent memory leaks
      document.removeEventListener('mousemove', mouseMoveHandler);
      document.removeEventListener('mouseup', mouseUpHandler);
      
      // Animate out
      container.style.opacity = '0';
      container.style.transform = 'translate(-50%, -50%) scale(0.95)';
      
      // Remove after animation
      setTimeout(() => {
        if (document.body.contains(container)) {
          document.body.removeChild(container);
        }
      }, 300);
    };

    contentContainer.appendChild(originalDiv);
    contentContainer.appendChild(divider);
    contentContainer.appendChild(translatedDiv);

    div.appendChild(header);
    div.appendChild(closeButton);
    div.appendChild(contentContainer);
    div.appendChild(footer);

    shadowRoot.appendChild(div);

    // Set essential styles on the container that need to be outside the shadow DOM
    Object.assign(container.style, {
      position: 'fixed',
      top: '50%',
      left: '50%',
      transform: 'translate(-50%, -50%)',
      zIndex: MAXIMUM_Z_INDEX,
      width: '40rem',
      maxWidth: '50vw',
    });

    return container;
  } catch (error) {
    throw new TypedError(
      'DOMPopupError',
      `Failed to create popup: ${
        error instanceof Error ? error.message : String(error)
      }`
    );
  }
}

export function showPopupToViewport(text: TranslationResult) {
  try {
    const popup = createPopup(text);
    document.body.appendChild(popup);
  } catch (error) {
    throw error;
  }
}
